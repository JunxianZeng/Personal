 	正则表达式是一个很强大的字符串处理工具，几乎任何关于字符串的操作都可以使用正则表达式来完成，作为一个爬虫工作者，每天和字符串打交道，正则表达式更是不可或缺的技能，正则表达式的在不同的语言中使用方式可能不一样，不过只要学会了任意一门语言的正则表达式用法，其他语言中大部分也只是换了个函数的名称而已，本质都是一样的。下面，我来介绍一下python中的正则表达式是怎么使用的。 

 	　　首先，python中的正则表达式大致分为以下几部分： 

1. 1.  				元字符 			
   2.  				模式 			
   3.  				函数 			
   4.  				re 内置对象用法 			
   5.  				分组用法 			
   6.  				环视用法 			

 	　　所有关于正则表达式的操作都使用 python 标准库中的 re 模块。 

 	一、元字符 （参见 python 模块 re 文档） 

- -  				.                    匹配任意字符（不包括换行符） 			
  -  				^                    匹配开始位置，多行模式下匹配每一行的开始 			
  -  				$                    匹配结束位置，多行模式下匹配每一行的结束 			
  -  				*                    匹配前一个元字符0到多次 			
  -  				+                    匹配前一个元字符1到多次 			
  -  				?                    匹配前一个元字符0到1次 			
  -  				{m,n}                匹配前一个元字符m到n次 			
  -  				\\                   转义字符，跟在其后的字符将失去作为特殊元字符的含义，例如\\.只能匹配.，不能再匹配任意字符 			
  -  				[]                   字符集，一个字符的集合，可匹配其中任意一个字符 			
  -  				|                    逻辑表达式 或 ，比如 a|b 代表可匹配 a 或者 b 			
  -  				(...)                分组，默认为捕获，即被分组的内容可以被单独取出，默认每个分组有个索引，从 1 开始，按照"("的顺序决定索引值 			
  -  				(?iLmsux)            分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见 模式 I
      			
  -  				(?:...)              分组的不捕获模式，计算索引时会跳过这个分组 			
  -  				(?P...)        分组的命名模式，取此分组中的内容时可以使用索引也可以使用name 			
  -  				(?P=name)            分组的引用模式，可在同一个正则表达式用引用前面命名过的正则 			
  -  				(?#...)              注释，不影响正则表达式其它部分,用法参见 模式 I 			
  -  				(?=...)              顺序肯定环视，表示所在位置右侧能够匹配括号内正则 			
  -  				(?!...)              顺序否定环视，表示所在位置右侧不能匹配括号内正则 			
  -  				(?<=...)             逆序肯定环视，表示所在位置左侧能够匹配括号内正则 			
  -  				(? 			
  -  				(?(id/name)yes|no)   若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则
      			
  -  				\number              匹配和前面索引为number的分组捕获到的内容一样的字符串 			
  -  				\A                   匹配字符串开始位置，忽略多行模式 			
  -  				\Z                   匹配字符串结束位置，忽略多行模式 			
  -  				\b                   匹配位于单词开始或结束位置的空字符串 			
  -  				\B                   匹配不位于单词开始或结束位置的空字符串 			
  -  				\d                   匹配一个数字， 相当于 [0-9] 			
  -  				\D                   匹配非数字,相当于 [^0-9] 			
  -  				\s                   匹配任意空白字符， 相当于 [ \t\n\r\f\v] 			
  -  				\S                   匹配非空白字符，相当于 [^ \t\n\r\f\v] 			
  -  				\w                   匹配数字、字母、下划线中任意一个字符， 相当于 [a-zA-Z0-9_] 			
  -  				\W                   匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_ 			



http://www.????/????/????/???.mp4



/^http:\/\/www\..+\.mp4$/







**Python3中正则表达式**

1

**re.match**

尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。'''

re.match(pattern, string, flags=0)

2

**re.search**

扫描整个字符串并返回第一个成功的匹配。'''

re.search(pattern, string, flags=0)

3

**re.findall**

搜索字符串，以列表形式返回全部能匹配的子串。'''

re.findall(string[, pos[, endpos]])

参数：

**string**待匹配的字符串。

**pos**可选参数，指定字符串的起始位置，默认为。

**endpos**可选参数，指定字符串的结束位置，默认为字符串的长度。

[ ]内为选填项，可忽略

4

re.sub

替换字符串中每一个匹配的子串后返回替换后的字符串。'''

re.sub(pattern, repl, string, count=0)

参数：

**pattern**正则中的模式字符串。

**repl**替换的字符串，也可为一个函数。

**string**要被查找替换的原始字符串。

**count**模式匹配后替换的最大次数，默认表示替换所有的匹配。

5

**re.compile**

将正则字符串编译成正则表达式对象。'''

re.compile(pattern[, flags])

参数：

**pattern**一个字符串形式的正则表达式

**flag**可选，表示匹配模式，比如忽略大小写，多行模式等，

具体参数为：

**re.L**表示特殊字符集\w, \W,       \b, \B, \s, \S依赖于当前环境

**re.M**多行模式，影响^和$

**re.S**即为' . '并且包括换行符在内的任意字符

**re.U**表示特殊字符集\w, \W,       \b, \B, \d, \D, \s, \S依赖于Unicode字符属性数据库

**re.X**为了增加可读性，忽略空格和'       # '后面的注释

**re.I**忽略大小写









mysql

https://cloud.tencent.com/developer/article/1353190